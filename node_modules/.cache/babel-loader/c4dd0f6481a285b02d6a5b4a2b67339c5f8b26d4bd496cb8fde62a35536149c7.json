{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Statement = void 0;\nconst format_error_1 = require(\"./utils/format-error\");\n/**\n * Promisified wrapper for the sqlite3#Statement interface.\n */\nclass Statement {\n  constructor(stmt) {\n    this.stmt = stmt;\n  }\n  /**\n   * Returns the underlying sqlite3 Statement instance\n   */\n  getStatementInstance() {\n    return this.stmt;\n  }\n  /**\n   * Binds parameters to the prepared statement.\n   *\n   * Binding parameters with this function completely resets the statement object and row cursor\n   * and removes all previously bound parameters, if any.\n   */\n  bind() {\n    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n      params[_key] = arguments[_key];\n    }\n    return new Promise((resolve, reject) => {\n      this.stmt.bind(...params, err => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n        resolve();\n      });\n    });\n  }\n  /**\n   * Resets the row cursor of the statement and preserves the parameter bindings.\n   * Use this function to re-execute the same query with the same bindings.\n   */\n  reset() {\n    return new Promise(resolve => {\n      this.stmt.reset(() => {\n        resolve();\n      });\n    });\n  }\n  /**\n   * Finalizes the statement. This is typically optional, but if you experience long delays before\n   * the next query is executed, explicitly finalizing your statement might be necessary.\n   * This might be the case when you run an exclusive query (see section Control Flow).\n   * After the statement is finalized, all further function calls on that statement object\n   * will throw errors.\n   */\n  finalize() {\n    return new Promise((resolve, reject) => {\n      this.stmt.finalize(err => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n        resolve();\n      });\n    });\n  }\n  /**\n   * Binds parameters and executes the statement.\n   *\n   * If you specify bind parameters, they will be bound to the statement before it is executed.\n   * Note that the bindings and the row cursor are reset when you specify even a single bind parameter.\n   *\n   * The execution behavior is identical to the Database#run method with the difference that the\n   * statement will not be finalized after it is run. This means you can run it multiple times.\n   *\n   * @param {any} [params, ...] When the SQL statement contains placeholders, you\n   * can pass them in here. They will be bound to the statement before it is\n   * executed. There are three ways of passing bind parameters: directly in\n   * the function's arguments, as an array, and as an object for named\n   * parameters. This automatically sanitizes inputs.\n   */\n  run() {\n    for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      params[_key2] = arguments[_key2];\n    }\n    return new Promise((resolve, reject) => {\n      const stmt = this;\n      this.stmt.run(...params, function (err) {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n        resolve({\n          stmt,\n          lastID: this.lastID,\n          changes: this.changes\n        });\n      });\n    });\n  }\n  /**\n   * Binds parameters, executes the statement and retrieves the first result row.\n   * The parameters are the same as the Statement#run function, with the following differences:\n   *\n   * Using this method can leave the database locked, as the database awaits further\n   * calls to Statement#get to retrieve subsequent rows. To inform the database that you\n   * are finished retrieving rows, you should either finalize (with Statement#finalize)\n   * or reset (with Statement#reset) the statement.\n   *\n   * @param {any} [params, ...] When the SQL statement contains placeholders, you\n   * can pass them in here. They will be bound to the statement before it is\n   * executed. There are three ways of passing bind parameters: directly in\n   * the function's arguments, as an array, and as an object for named\n   * parameters. This automatically sanitizes inputs.\n   */\n  get() {\n    for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      params[_key3] = arguments[_key3];\n    }\n    return new Promise((resolve, reject) => {\n      this.stmt.get(...params, (err, row) => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n        resolve(row);\n      });\n    });\n  }\n  /**\n   * Binds parameters, executes the statement and calls the callback with all result rows.\n   * The parameters are the same as the Statement#run function, with the following differences:\n   *\n   * If the result set is empty, it will resolve to an empty array, otherwise it contains an\n   * object for each result row which in turn contains the values of that row.\n   * Like with Statement#run, the statement will not be finalized after executing this function.\n   *\n   * @param {any} [params, ...] When the SQL statement contains placeholders, you\n   * can pass them in here. They will be bound to the statement before it is\n   * executed. There are three ways of passing bind parameters: directly in\n   * the function's arguments, as an array, and as an object for named\n   * parameters. This automatically sanitizes inputs.\n   *\n   * @see https://github.com/mapbox/node-sqlite3/wiki/API#databaseallsql-param--callback\n   */\n  all() {\n    for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      params[_key4] = arguments[_key4];\n    }\n    return new Promise((resolve, reject) => {\n      this.stmt.all(...params, (err, rows) => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n        resolve(rows);\n      });\n    });\n  }\n  each() {\n    for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      params[_key5] = arguments[_key5];\n    }\n    return new Promise((resolve, reject) => {\n      const callback = params.pop();\n      if (!callback || typeof callback !== 'function') {\n        throw new Error('sqlite: Last param of Statement#each() must be a callback function');\n      }\n      if (params.length > 0) {\n        const positional = params.pop();\n        if (typeof positional === 'function') {\n          throw new Error('sqlite: Statement#each() should only have a single callback defined. See readme for usage.');\n        }\n        params.push(positional);\n      }\n      this.stmt.each(...params, (err, row) => {\n        if (err) {\n          return callback((0, format_error_1.formatError)(err), null);\n        }\n        callback(null, row);\n      }, (err, count) => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n        resolve(count);\n      });\n    });\n  }\n}\nexports.Statement = Statement;","map":{"version":3,"names":["format_error_1","require","Statement","constructor","stmt","getStatementInstance","bind","_len","arguments","length","params","Array","_key","Promise","resolve","reject","err","formatError","reset","finalize","run","_len2","_key2","lastID","changes","get","_len3","_key3","row","all","_len4","_key4","rows","each","_len5","_key5","callback","pop","Error","positional","push","count","exports"],"sources":["../src/Statement.ts"],"sourcesContent":[null],"mappings":";;;;;;AAEA,MAAAA,cAAA,GAAAC,OAAA;AAEA;;;AAGA,MAAaC,SAAS;EAGpBC,YAAaC,IAAO;IAClB,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;EAEA;;;EAGAC,oBAAoBA,CAAA;IAClB,OAAO,IAAI,CAACD,IAAI;EAClB;EAEA;;;;;;EAMAE,IAAIA,CAAA,EAAkB;IAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAbC,MAAa,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;MAAbF,MAAa,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;IAAA;IACpB,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;MACrC,IAAI,CAACX,IAAI,CAACE,IAAI,CAAC,GAAGI,MAAM,EAAEM,GAAG,IAAG;QAC9B,IAAIA,GAAG,EAAE;UACP,OAAOD,MAAM,CAAC,IAAAf,cAAA,CAAAiB,WAAW,EAACD,GAAG,CAAC,CAAC;;QAGjCF,OAAO,EAAE;MACX,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA;;;;EAIAI,KAAKA,CAAA;IACH,OAAO,IAAIL,OAAO,CAACC,OAAO,IAAG;MAC3B,IAAI,CAACV,IAAI,CAACc,KAAK,CAAC,MAAK;QACnBJ,OAAO,EAAE;MACX,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA;;;;;;;EAOAK,QAAQA,CAAA;IACN,OAAO,IAAIN,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;MACrC,IAAI,CAACX,IAAI,CAACe,QAAQ,CAACH,GAAG,IAAG;QACvB,IAAIA,GAAG,EAAE;UACP,OAAOD,MAAM,CAAC,IAAAf,cAAA,CAAAiB,WAAW,EAACD,GAAG,CAAC,CAAC;;QAGjCF,OAAO,EAAE;MACX,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA;;;;;;;;;;;;;;;EAeAM,GAAGA,CAAA,EAAkB;IAAA,SAAAC,KAAA,GAAAb,SAAA,CAAAC,MAAA,EAAbC,MAAa,OAAAC,KAAA,CAAAU,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAbZ,MAAa,CAAAY,KAAA,IAAAd,SAAA,CAAAc,KAAA;IAAA;IACnB,OAAO,IAAIT,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;MACrC,MAAMX,IAAI,GAAG,IAAI;MAEjB,IAAI,CAACA,IAAI,CAACgB,GAAG,CAAC,GAAGV,MAAM,EAAE,UAAUM,GAAG;QACpC,IAAIA,GAAG,EAAE;UACP,OAAOD,MAAM,CAAC,IAAAf,cAAA,CAAAiB,WAAW,EAACD,GAAG,CAAC,CAAC;;QAGjCF,OAAO,CAAC;UACNV,IAAI;UACJmB,MAAM,EAAE,IAAI,CAACA,MAAM;UACnBC,OAAO,EAAE,IAAI,CAACA;SACf,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA;;;;;;;;;;;;;;;EAeAC,GAAGA,CAAA,EAA2B;IAAA,SAAAC,KAAA,GAAAlB,SAAA,CAAAC,MAAA,EAAbC,MAAa,OAAAC,KAAA,CAAAe,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAbjB,MAAa,CAAAiB,KAAA,IAAAnB,SAAA,CAAAmB,KAAA;IAAA;IAC5B,OAAO,IAAId,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;MACrC,IAAI,CAACX,IAAI,CAACqB,GAAG,CAAC,GAAGf,MAAM,EAAE,CAACM,GAAG,EAAEY,GAAO,KAAI;QACxC,IAAIZ,GAAG,EAAE;UACP,OAAOD,MAAM,CAAC,IAAAf,cAAA,CAAAiB,WAAW,EAACD,GAAG,CAAC,CAAC;;QAGjCF,OAAO,CAACc,GAAG,CAAC;MACd,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA;;;;;;;;;;;;;;;;EAgBAC,GAAGA,CAAA,EAA6B;IAAA,SAAAC,KAAA,GAAAtB,SAAA,CAAAC,MAAA,EAAbC,MAAa,OAAAC,KAAA,CAAAmB,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAbrB,MAAa,CAAAqB,KAAA,IAAAvB,SAAA,CAAAuB,KAAA;IAAA;IAC9B,OAAO,IAAIlB,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;MACrC,IAAI,CAACX,IAAI,CAACyB,GAAG,CAAC,GAAGnB,MAAM,EAAE,CAACM,GAAG,EAAEgB,IAAQ,KAAI;QACzC,IAAIhB,GAAG,EAAE;UACP,OAAOD,MAAM,CAAC,IAAAf,cAAA,CAAAiB,WAAW,EAACD,GAAG,CAAC,CAAC;;QAGjCF,OAAO,CAACkB,IAAI,CAAC;MACf,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAyCAC,IAAIA,CAAA,EAA2B;IAAA,SAAAC,KAAA,GAAA1B,SAAA,CAAAC,MAAA,EAAbC,MAAa,OAAAC,KAAA,CAAAuB,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAbzB,MAAa,CAAAyB,KAAA,IAAA3B,SAAA,CAAA2B,KAAA;IAAA;IAC7B,OAAO,IAAItB,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;MACrC,MAAMqB,QAAQ,GAA0B1B,MAAM,CAAC2B,GAAG,EAAE;MAEpD,IAAI,CAACD,QAAQ,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;QAC/C,MAAM,IAAIE,KAAK,CACb,oEAAoE,CACrE;;MAGH,IAAI5B,MAAM,CAACD,MAAM,GAAG,CAAC,EAAE;QACrB,MAAM8B,UAAU,GAAG7B,MAAM,CAAC2B,GAAG,EAAE;QAE/B,IAAI,OAAOE,UAAU,KAAK,UAAU,EAAE;UACpC,MAAM,IAAID,KAAK,CACb,4FAA4F,CAC7F;;QAGH5B,MAAM,CAAC8B,IAAI,CAACD,UAAU,CAAC;;MAGzB,IAAI,CAACnC,IAAI,CAAC6B,IAAI,CACZ,GAAGvB,MAAM,EACT,CAACM,GAAG,EAAEY,GAAG,KAAI;QACX,IAAIZ,GAAG,EAAE;UACP,OAAOoB,QAAQ,CAAC,IAAApC,cAAA,CAAAiB,WAAW,EAACD,GAAG,CAAC,EAAE,IAAI,CAAC;;QAGzCoB,QAAQ,CAAC,IAAI,EAAER,GAAG,CAAC;MACrB,CAAC,EACD,CAACZ,GAAG,EAAEyB,KAAK,KAAI;QACb,IAAIzB,GAAG,EAAE;UACP,OAAOD,MAAM,CAAC,IAAAf,cAAA,CAAAiB,WAAW,EAACD,GAAG,CAAC,CAAC;;QAGjCF,OAAO,CAAC2B,KAAK,CAAC;MAChB,CAAC,CACF;IACH,CAAC,CAAC;EACJ;;AAtOFC,OAAA,CAAAxC,SAAA,GAAAA,SAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}