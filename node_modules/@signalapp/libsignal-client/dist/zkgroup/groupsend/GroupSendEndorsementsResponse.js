"use strict";
//
// Copyright 2024 Signal Messenger, LLC.
// SPDX-License-Identifier: AGPL-3.0-only
//
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const ByteArray_1 = require("../internal/ByteArray");
const Native = require("../../../Native");
const Constants_1 = require("../internal/Constants");
const UuidCiphertext_1 = require("../groups/UuidCiphertext");
const Address_1 = require("../../Address");
const GroupSendEndorsement_1 = require("./GroupSendEndorsement");
/**
 * A set of endorsements of the members in a group, along with a proof of their validity.
 *
 * Issued by the group server based on the group's member ciphertexts. The endorsements will
 * eventually be verified by the chat server in the form of {@link GroupSendFullToken}s. See
 * {@link GroupSendEndorsement} for a full description of the endorsement flow from the client's
 * perspective.
 */
class GroupSendEndorsementsResponse extends ByteArray_1.default {
    constructor(contents) {
        super(contents, Native.GroupSendEndorsementsResponse_CheckValidContents);
    }
    /**
     * Issues a new set of endorsements for `groupMembers`.
     *
     * `groupMembers` should include `requestingUser` as well.
     */
    static issue(groupMembers, keyPair) {
        const random = (0, crypto_1.randomBytes)(Constants_1.RANDOM_LENGTH);
        return this.issueWithRandom(groupMembers, keyPair, random);
    }
    /**
     * Issues a new set of endorsements for `groupMembers`, with an explicity-chosen expiration and
     * source of randomness.
     *
     * Should only be used for testing purposes.
     *
     * @see {@link GroupSendEndorsementsResponse#issue}
     */
    static issueWithRandom(groupMembers, keyPair, random) {
        return new GroupSendEndorsementsResponse(Native.GroupSendEndorsementsResponse_IssueDeterministic(UuidCiphertext_1.default.serializeAndConcatenate(groupMembers), keyPair.contents, random));
    }
    /** Returns the expiration for the contained endorsements. */
    getExpiration() {
        return new Date(1000 * Native.GroupSendEndorsementsResponse_GetExpiration(this.contents));
    }
    /**
     * Receives, validates, and extracts the endorsements from a response.
     *
     * Note that the `receive` operation is provided for both {@link ServiceId}s and {@link
     * UuidCiphertext}s. If you already have the ciphertexts for the group members available, {@link
     * #receiveWithCiphertexts} should be faster; if you don't, this method is faster than generating
     * the ciphertexts and throwing them away afterwards.
     *
     * `localUser` should be included in `groupMembers`.
     *
     * @throws {VerificationFailedError} if the endorsements are not valid for any reason
     */
    receiveWithServiceIds(groupMembers, localUser, groupParams, serverParams, now = new Date()) {
        const endorsementContents = Native.GroupSendEndorsementsResponse_ReceiveAndCombineWithServiceIds(this.contents, Address_1.ServiceId.toConcatenatedFixedWidthBinary(groupMembers), localUser.getServiceIdFixedWidthBinary(), Math.floor(now.getTime() / 1000), groupParams.contents, serverParams);
        const endorsements = endorsementContents.map((next) => {
            // Normally we don't notice the cost of validating just-created zkgroup objects,
            // but in this case we may have up to 1000 of these. Let's assume they're created correctly.
            return new GroupSendEndorsement_1.default(next, ByteArray_1.UNCHECKED_AND_UNCLONED);
        });
        const combinedEndorsement = endorsements.pop();
        if (!combinedEndorsement) {
            throw new Error("GroupSendEndorsementsResponse_ReceiveAndCombineWithServiceIds didn't produce a combined endorsement");
        }
        return { endorsements, combinedEndorsement };
    }
    /**
     * Receives, validates, and extracts the endorsements from a response.
     *
     * Note that the `receive` operation is provided for both {@link ServiceId}s and {@link
     * UuidCiphertext}s. If you already have the ciphertexts for the group members available, this
     * method should be faster; if you don't, {@link #receiveWithServiceIds} is faster than generating
     * the ciphertexts and throwing them away afterwards.
     *
     * `localUser` should be included in `groupMembers`.
     *
     * @throws {VerificationFailedError} if the endorsements are not valid for any reason
     */
    receiveWithCiphertexts(groupMembers, localUser, serverParams, now = new Date()) {
        const endorsementContents = Native.GroupSendEndorsementsResponse_ReceiveAndCombineWithCiphertexts(this.contents, UuidCiphertext_1.default.serializeAndConcatenate(groupMembers), localUser.contents, Math.floor(now.getTime() / 1000), serverParams);
        const endorsements = endorsementContents.map((next) => {
            // Normally we don't notice the cost of validating just-created zkgroup objects,
            // but in this case we may have up to 1000 of these. Let's assume they're created correctly.
            return new GroupSendEndorsement_1.default(next, ByteArray_1.UNCHECKED_AND_UNCLONED);
        });
        const combinedEndorsement = endorsements.pop();
        if (!combinedEndorsement) {
            throw new Error("GroupSendEndorsementsResponse_ReceiveAndCombineWithCiphertexts didn't produce a combined endorsement");
        }
        return { endorsements, combinedEndorsement };
    }
}
exports.default = GroupSendEndorsementsResponse;
//# sourceMappingURL=GroupSendEndorsementsResponse.js.map