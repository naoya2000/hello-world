/// <reference types="node" />
import type { ReadonlyDeep } from 'type-fest';
import * as Native from '../Native';
import { Wrapper } from '../Native';
import { Buffer } from 'node:buffer';
export declare enum Environment {
    Staging = 0,
    Production = 1
}
export type ServiceAuth = {
    username: string;
    password: string;
};
export type CDSRequestOptionsType = {
    e164s: Array<string>;
    acisAndAccessKeys: Array<{
        aci: string;
        accessKey: string;
    }>;
    returnAcisWithoutUaks: boolean;
    abortSignal?: AbortSignal;
};
export type CDSResponseEntryType<Aci, Pni> = {
    aci: Aci | undefined;
    pni: Pni | undefined;
};
export type CDSResponseEntries<Aci, Pni> = Map<string, CDSResponseEntryType<Aci, Pni>>;
export interface CDSResponseType<Aci, Pni> {
    entries: CDSResponseEntries<Aci, Pni>;
    debugPermitsUsed: number;
}
export type ChatRequest = Readonly<{
    verb: string;
    path: string;
    headers: ReadonlyArray<[string, string]>;
    body?: Uint8Array;
    timeoutMillis?: number;
}>;
type ConnectionManager = Wrapper<Native.ConnectionManager>;
export declare function newNativeHandle<T>(handle: T): Wrapper<T>;
/** Low-level async runtime control, mostly just exported for testing. */
export declare class TokioAsyncContext {
    readonly _nativeHandle: Native.TokioAsyncContext;
    constructor(handle: Native.TokioAsyncContext);
    makeCancellable<T>(abortSignal: AbortSignal | undefined, promise: Promise<T>): Promise<T>;
}
export declare class ChatServerMessageAck {
    private readonly asyncContext;
    readonly _nativeHandle: Native.ServerMessageAck;
    private promise;
    constructor(asyncContext: TokioAsyncContext, _nativeHandle: Native.ServerMessageAck);
    send(statusCode: number): Promise<void>;
}
export interface ChatServiceListener {
    /**
     * Called when the server delivers an incoming message to the client.
     *
     * `timestamp` is in milliseconds.
     *
     * If `ack`'s `send` method is not called, the server will leave this message in the message
     * queue and attempt to deliver it again in the future.
     */
    onIncomingMessage(envelope: Buffer, timestamp: number, ack: ChatServerMessageAck): void;
    /**
     * Called when the server indicates that there are no further messages in the message queue.
     *
     * Note that further messages may still be delivered; this merely indicates that all messages that
     * were in the queue *when the connection was established* have been delivered.
     */
    onQueueEmpty(): void;
    /**
     * Called when the client gets disconnected from the server.
     *
     * This includes both deliberate disconnects as well as unexpected socket closures that will be
     * automatically retried.
     *
     * Will not be called if no other requests have been invoked for this connection attempt. That is,
     * you should never see this as the first callback, nor two of these callbacks in a row.
     */
    onConnectionInterrupted(): void;
}
/**
 * Provides API methods to connect and communicate with the Chat Service.
 * Before sending/receiving requests, a {@link #connect()} method must be called.
 * It's also important to call {@link #disconnect()} method when the instance is no longer needed.
 */
export type ChatService = {
    /**
     * Initiates establishing of the underlying connection to the Chat Service. Once the
     * service is connected, all the requests will be using the established connection. Also, if the
     * connection is lost for any reason other than the call to {@link #disconnect()}, an automatic
     * reconnect attempt will be made.
     *
     * Calling this method will result in starting to accept incoming requests from the Chat Service.
     *
     * @throws {AppExpiredError} if the current app version is too old (as judged by the server).
     * @throws {DeviceDelinkedError} if the current device has been delinked.
     * @throws {LibSignalError} with other codes for other failures.
     */
    connect(options?: {
        abortSignal?: AbortSignal;
    }): Promise<Native.ChatServiceDebugInfo>;
    /**
     * Initiates termination of the underlying connection to the Chat Service. After the service is
     * disconnected, it will not attempt to automatically reconnect until you call
     * {@link #connect()}.
     *
     * Note: the same instance of `ChatService` can be reused after {@link #disconnect()} was
     * called.
     */
    disconnect(): Promise<void>;
    /**
     * Sends request to the Chat Service.
     *
     * In addition to the response, an object containing debug information about the request flow is
     * returned.
     *
     * @throws {ChatServiceInactive} if you haven't called {@link #connect()} (as a
     * rejection of the promise).
     */
    fetchAndDebug(chatRequest: ChatRequest, options?: {
        abortSignal?: AbortSignal;
    }): Promise<Native.ResponseAndDebugInfo>;
    /**
     * Sends request to the Chat Service.
     *
     * @throws {ChatServiceInactive} if you haven't called {@link #connect()} (as a
     * rejection of the promise).
     */
    fetch(chatRequest: ChatRequest, options?: {
        abortSignal?: AbortSignal;
    }): Promise<Native.ChatResponse>;
};
/**
 * Provides API methods to connect and communicate with the Chat Service over an authenticated channel.
 */
export declare class AuthenticatedChatService implements ChatService {
    private readonly asyncContext;
    readonly chatService: Wrapper<Native.Chat>;
    constructor(asyncContext: TokioAsyncContext, connectionManager: ConnectionManager, username: string, password: string, receiveStories: boolean, listener: ChatServiceListener);
    disconnect(): Promise<void>;
    connect(options?: {
        abortSignal?: AbortSignal;
    }): Promise<Native.ChatServiceDebugInfo>;
    fetchAndDebug(chatRequest: ChatRequest, options?: {
        abortSignal?: AbortSignal;
    }): Promise<Native.ResponseAndDebugInfo>;
    fetch(chatRequest: ChatRequest, options?: {
        abortSignal?: AbortSignal;
    }): Promise<Native.ChatResponse>;
}
/**
 * Provides API methods to connect and communicate with the Chat Service over an unauthenticated channel.
 */
export declare class UnauthenticatedChatService implements ChatService {
    private readonly asyncContext;
    readonly chatService: Wrapper<Native.Chat>;
    constructor(asyncContext: TokioAsyncContext, connectionManager: ConnectionManager);
    disconnect(): Promise<void>;
    connect(options?: {
        abortSignal?: AbortSignal;
    }): Promise<Native.ChatServiceDebugInfo>;
    fetchAndDebug(chatRequest: ChatRequest, options?: {
        abortSignal?: AbortSignal;
    }): Promise<Native.ResponseAndDebugInfo>;
    fetch(chatRequest: ChatRequest, options?: {
        abortSignal?: AbortSignal;
    }): Promise<Native.ChatResponse>;
}
export declare function buildHttpRequest(chatRequest: ChatRequest): Wrapper<Native.HttpRequest>;
export declare class Net {
    private readonly asyncContext;
    private readonly connectionManager;
    /**
     * Instance of the {@link Svr3Client} to access SVR3.
     */
    svr3: Svr3Client;
    constructor(env: Environment, userAgent: string);
    /**
     * Creates a new instance of {@link AuthenticatedChatService}.
     *
     * Note that created `AuthenticatedChatService` will hold a **non-garbage-collectable** reference to `listener`.
     * If `listener` contains a strong reference to this ChatService (directly or indirectly), both objects will be kept
     * alive even with no other references. If such reference cycle is created, it's the responsibility of the caller
     * to eventually break it (either using a weak reference or by assigning over the strong reference).
     */
    newAuthenticatedChatService(username: string, password: string, receiveStories: boolean, listener: ChatServiceListener): AuthenticatedChatService;
    /**
     * Creates a new instance of {@link UnauthenticatedChatService}.
     */
    newUnauthenticatedChatService(): UnauthenticatedChatService;
    /**
     * Enables/disables IPv6 for all new connections (until changed).
     *
     * The flag is `true` by default.
     */
    setIpv6Enabled(ipv6Enabled: boolean): void;
    /**
     * Sets the proxy host to be used for all new connections (until overridden).
     *
     * Sets a domain name and port to be used to proxy all new outgoing
     * connections. The proxy can be overridden by calling this method again or
     * unset by calling {@link #clearProxy}.
     *
     * Throws if the host or port is structurally invalid, such as a port that doesn't fit in u16.
     */
    setProxy(host: string, port: number): void;
    /**
     * Ensures that future connections will be made directly, not through a proxy.
     *
     * Clears any proxy configuration set via {@link #setProxy}. If none was set, calling this
     * method is a no-op.
     */
    clearProxy(): void;
    /**
     * Notifies libsignal that the network has changed.
     *
     * This will lead to, e.g. caches being cleared and cooldowns being reset.
     */
    onNetworkChange(): void;
    cdsiLookup({ username, password }: Readonly<ServiceAuth>, { e164s, acisAndAccessKeys, returnAcisWithoutUaks, abortSignal, }: ReadonlyDeep<CDSRequestOptionsType>): Promise<CDSResponseType<string, string>>;
}
/**
 * This interface provides functionality for communicating with SVR3
 *
 * Its instance can be obtained from an {@link Net#svr3} property
 * of the {@link Net} class.
 *
 * Example usage:
 *
 * @example
 * ```ts
 * import { Environment, Net } from '../net';
 * // Obtain an instance
 * const SVR3 = new Net(Environment.Staging).svr3;
 * // Instantiate ServiceAuth with the username and password obtained from the Chat Server.
 * const auth = { username: USERNAME, password: ENCLAVE_PASSWORD };
 * // Store a value in SVR3. Here 10 is the number of permitted restore attempts.
 * const shareSet = await SVR3.backup(SECRET_TO_BE_STORED, PASSWORD, 10, auth);
 * const restoredSecret = await SVR3.restore( PASSWORD, shareSet, auth);
 * ```
 */
export interface Svr3Client {
    /**
     * Backup a secret to SVR3.
     *
     * Error messages are log-safe and do not contain any sensitive data.
     *
     * @param what - The secret to be stored. Must be 32 bytes long.
     * @param password - User-provided password that will be used to derive the
     * encryption key for the secret.
     * @param maxTries - Number of times the secret will be allowed to be guessed.
     * Each call to {@link Svr3Client#restore} that has reached the server will
     * decrement the counter. Must be positive.
     * @param auth - An instance of {@link ServiceAuth} containing the username
     * and password obtained from the Chat Server. The password is an OTP which is
     * generally good for about 15 minutes, therefore it can be reused for the
     * subsequent calls to either backup or restore that are not too far apart in
     * time.
     * @returns A `Promise` which--when awaited--will return a byte array with a
     * serialized masked share set. It is supposed to be an opaque blob for the
     * clients and therefore no assumptions should be made about its contents.
     * This byte array should be stored by the clients and used to restore the
     * secret along with the password. Please note that masked share set does not
     * have to be treated as secret.
     *
     * The returned `Promise` can also fail due to the network issues (including a
     * connection timeout), problems establishing the Noise connection to the
     * enclaves, or invalid arguments' values. {@link IoError} errors can, in
     * general, be retried, although there is already a retry-with-backoff
     * mechanism inside libsignal used to connect to the SVR3 servers. Other
     * exceptions are caused by the bad input or data missing on the server. They
     * are therefore non-actionable and are guaranteed to be thrown again when
     * retried.
     */
    backup(what: Buffer, password: string, maxTries: number, auth: Readonly<ServiceAuth>, options?: {
        abortSignal?: AbortSignal;
    }): Promise<Buffer>;
    /**
     * Restore a secret from SVR3.
     *
     * Error messages are log-safe and do not contain any sensitive data.
     *
     * @param password - User-provided password that will be used to derive the
     * decryption key for the secret.
     * @param shareSet - a serialized masked share set returned by a call to
     * {@link Svr3Client#backup}.
     * @param auth - An instance of {@link ServiceAuth} containing the username
     * and password obtained from the Chat Server. The password is an OTP which is
     * generally good for about 15 minutes, therefore it can be reused for the
     * subsequent calls to either backup or restore that are not too far apart in
     * time.
     * @returns A `Promise` which--when awaited--will return a
     * {@link RestoredSecret} object, containing the restored secret.
     *
     * The returned `Promise` can also fail due to the network issues (including
     * the connection timeout), problems establishing the Noise connection to the
     * enclaves, or invalid arguments' values. {@link IoError} errors can, in
     * general, be retried, although there is already a retry-with-backoff
     * mechanism inside libsignal used to connect to the SVR3 servers. Other
     * exceptions are caused by the bad input or data missing on the server. They
     * are therefore non-actionable and are guaranteed to be thrown again when
     * retried.
     *
     * - {@link SvrDataMissingError} is returned when the maximum restore attempts
     * number has been exceeded or if the value has never been backed up.
     * - {@link SvrRestoreFailedError} is returned when the combination of the
     * password and masked share set does not result in successful restoration
     * of the secret.
     * - {@link SvrRequestFailedError} is returned when the de-serialization of a
     * masked share set fails, or when the server requests fail for reasons
     * other than "maximum attempts exceeded".
     */
    restore(password: string, shareSet: Buffer, auth: Readonly<ServiceAuth>, options?: {
        abortSignal?: AbortSignal;
    }): Promise<RestoredSecret>;
    /**
     * Remove a value stored in SVR3.
     *
     * This method will succeed even if the data has never been backed up in the
     * first place.
     *
     * Error messages are log-safe and do not contain any sensitive data.
     *
     * @param auth - An instance of {@link ServiceAuth} containing the username
     * and password obtained from the Chat Server. The password is an OTP which is
     * generally good for about 15 minutes, therefore it can be reused for the
     * subsequent calls to either backup or restore that are not too far apart in
     * time.
     * @returns A `Promise` successful completion of which will mean the data has
     * been removed.
     *
     * The returned `Promise` can also fail due to the network issues (including
     * the connection timeout), problems establishing the Noise connection to the
     * enclaves, or invalid arguments' values. {@link IoError} errors can, in
     * general, be retried, although there is already a retry-with-backoff
     * mechanism inside libsignal used to connect to the SVR3 servers. Other
     * exceptions are caused by the bad input or data missing on the server. They
     * are therefore non-actionable and are guaranteed to be thrown again when
     * retried.
     */
    remove(auth: Readonly<ServiceAuth>, options?: {
        abortSignal?: AbortSignal;
    }): Promise<void>;
}
/**
 * A simple data class containing the secret restored from SVR3 as well as the
 * number of restore attempts remaining.
 */
export declare class RestoredSecret {
    readonly triesRemaining: number;
    readonly value: Buffer;
    constructor(serialized: Buffer);
}
export {};
