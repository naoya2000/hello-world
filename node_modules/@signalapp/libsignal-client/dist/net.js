"use strict";
//
// Copyright 2023 Signal Messenger, LLC.
// SPDX-License-Identifier: AGPL-3.0-only
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestoredSecret = exports.Net = exports.buildHttpRequest = exports.UnauthenticatedChatService = exports.AuthenticatedChatService = exports.ChatServerMessageAck = exports.TokioAsyncContext = exports.newNativeHandle = exports.Environment = void 0;
const Native = require("../Native");
const Address_1 = require("./Address");
const node_buffer_1 = require("node:buffer");
const DEFAULT_CHAT_REQUEST_TIMEOUT_MILLIS = 5000;
// This must match the libsignal-bridge Rust enum of the same name.
var Environment;
(function (Environment) {
    Environment[Environment["Staging"] = 0] = "Staging";
    Environment[Environment["Production"] = 1] = "Production";
})(Environment = exports.Environment || (exports.Environment = {}));
function newNativeHandle(handle) {
    return {
        _nativeHandle: handle,
    };
}
exports.newNativeHandle = newNativeHandle;
/** Low-level async runtime control, mostly just exported for testing. */
class TokioAsyncContext {
    constructor(handle) {
        this._nativeHandle = handle;
    }
    makeCancellable(abortSignal, promise) {
        if (abortSignal !== undefined &&
            '_cancellationToken' in promise &&
            typeof promise._cancellationToken === 'bigint') {
            const cancellationToken = promise._cancellationToken;
            const cancel = () => {
                Native.TokioAsyncContext_cancel(this, cancellationToken);
            };
            if (abortSignal.aborted) {
                cancel();
            }
            else {
                abortSignal.addEventListener('abort', cancel);
            }
        }
        return promise;
    }
}
exports.TokioAsyncContext = TokioAsyncContext;
class ChatServerMessageAck {
    constructor(asyncContext, _nativeHandle) {
        this.asyncContext = asyncContext;
        this._nativeHandle = _nativeHandle;
        this.promise = null;
    }
    send(statusCode) {
        if (!this.promise) {
            this.promise = Native.ServerMessageAck_SendStatus(this.asyncContext, this, statusCode);
        }
        return this.promise;
    }
}
exports.ChatServerMessageAck = ChatServerMessageAck;
/**
 * Provides API methods to connect and communicate with the Chat Service over an authenticated channel.
 */
class AuthenticatedChatService {
    constructor(asyncContext, connectionManager, username, password, receiveStories, listener) {
        this.asyncContext = asyncContext;
        this.chatService = newNativeHandle(Native.ChatService_new(connectionManager, username, password, receiveStories));
        const nativeChatListener = {
            _incoming_message(envelope, timestamp, ack) {
                listener.onIncomingMessage(envelope, timestamp, new ChatServerMessageAck(asyncContext, ack));
            },
            _queue_empty() {
                listener.onQueueEmpty();
            },
            _connection_interrupted() {
                listener.onConnectionInterrupted();
            },
        };
        Native.ChatServer_SetListener(asyncContext, this.chatService, nativeChatListener);
    }
    disconnect() {
        return Native.ChatService_disconnect(this.asyncContext, this.chatService);
    }
    connect(options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.ChatService_connect_auth(this.asyncContext, this.chatService));
    }
    fetchAndDebug(chatRequest, options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.ChatService_auth_send_and_debug(this.asyncContext, this.chatService, buildHttpRequest(chatRequest), chatRequest.timeoutMillis ?? DEFAULT_CHAT_REQUEST_TIMEOUT_MILLIS));
    }
    fetch(chatRequest, options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.ChatService_auth_send(this.asyncContext, this.chatService, buildHttpRequest(chatRequest), chatRequest.timeoutMillis ?? DEFAULT_CHAT_REQUEST_TIMEOUT_MILLIS));
    }
}
exports.AuthenticatedChatService = AuthenticatedChatService;
/**
 * Provides API methods to connect and communicate with the Chat Service over an unauthenticated channel.
 */
class UnauthenticatedChatService {
    constructor(asyncContext, connectionManager) {
        this.asyncContext = asyncContext;
        this.chatService = newNativeHandle(Native.ChatService_new(connectionManager, '', '', false));
    }
    disconnect() {
        return Native.ChatService_disconnect(this.asyncContext, this.chatService);
    }
    connect(options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.ChatService_connect_unauth(this.asyncContext, this.chatService));
    }
    fetchAndDebug(chatRequest, options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.ChatService_unauth_send_and_debug(this.asyncContext, this.chatService, buildHttpRequest(chatRequest), chatRequest.timeoutMillis ?? DEFAULT_CHAT_REQUEST_TIMEOUT_MILLIS));
    }
    fetch(chatRequest, options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.ChatService_unauth_send(this.asyncContext, this.chatService, buildHttpRequest(chatRequest), chatRequest.timeoutMillis ?? DEFAULT_CHAT_REQUEST_TIMEOUT_MILLIS));
    }
}
exports.UnauthenticatedChatService = UnauthenticatedChatService;
function buildHttpRequest(chatRequest) {
    const { verb, path, body, headers } = chatRequest;
    const bodyBuffer = body !== undefined ? node_buffer_1.Buffer.from(body) : null;
    const httpRequest = {
        _nativeHandle: Native.HttpRequest_new(verb, path, bodyBuffer),
    };
    headers.forEach((header) => {
        const [name, value] = header;
        Native.HttpRequest_add_header(httpRequest, name, value);
    });
    return httpRequest;
}
exports.buildHttpRequest = buildHttpRequest;
class Net {
    constructor(env, userAgent) {
        this.asyncContext = new TokioAsyncContext(Native.TokioAsyncContext_new());
        this.connectionManager = newNativeHandle(Native.ConnectionManager_new(env, userAgent));
        this.svr3 = new Svr3ClientImpl(this.asyncContext, this.connectionManager);
    }
    /**
     * Creates a new instance of {@link AuthenticatedChatService}.
     *
     * Note that created `AuthenticatedChatService` will hold a **non-garbage-collectable** reference to `listener`.
     * If `listener` contains a strong reference to this ChatService (directly or indirectly), both objects will be kept
     * alive even with no other references. If such reference cycle is created, it's the responsibility of the caller
     * to eventually break it (either using a weak reference or by assigning over the strong reference).
     */
    newAuthenticatedChatService(username, password, receiveStories, listener) {
        return new AuthenticatedChatService(this.asyncContext, this.connectionManager, username, password, receiveStories, listener);
    }
    /**
     * Creates a new instance of {@link UnauthenticatedChatService}.
     */
    newUnauthenticatedChatService() {
        return new UnauthenticatedChatService(this.asyncContext, this.connectionManager);
    }
    /**
     * Enables/disables IPv6 for all new connections (until changed).
     *
     * The flag is `true` by default.
     */
    setIpv6Enabled(ipv6Enabled) {
        Native.ConnectionManager_set_ipv6_enabled(this.connectionManager, ipv6Enabled);
    }
    /**
     * Sets the proxy host to be used for all new connections (until overridden).
     *
     * Sets a domain name and port to be used to proxy all new outgoing
     * connections. The proxy can be overridden by calling this method again or
     * unset by calling {@link #clearProxy}.
     *
     * Throws if the host or port is structurally invalid, such as a port that doesn't fit in u16.
     */
    setProxy(host, port) {
        Native.ConnectionManager_set_proxy(this.connectionManager, host, port);
    }
    /**
     * Ensures that future connections will be made directly, not through a proxy.
     *
     * Clears any proxy configuration set via {@link #setProxy}. If none was set, calling this
     * method is a no-op.
     */
    clearProxy() {
        Native.ConnectionManager_clear_proxy(this.connectionManager);
    }
    /**
     * Notifies libsignal that the network has changed.
     *
     * This will lead to, e.g. caches being cleared and cooldowns being reset.
     */
    onNetworkChange() {
        Native.ConnectionManager_on_network_change(this.connectionManager);
    }
    async cdsiLookup({ username, password }, { e164s, acisAndAccessKeys, returnAcisWithoutUaks, abortSignal, }) {
        const request = newNativeHandle(Native.LookupRequest_new());
        e164s.forEach((e164) => {
            Native.LookupRequest_addE164(request, e164);
        });
        acisAndAccessKeys.forEach(({ aci: aciStr, accessKey: accessKeyStr }) => {
            Native.LookupRequest_addAciAndAccessKey(request, Address_1.Aci.parseFromServiceIdString(aciStr).getServiceIdFixedWidthBinary(), node_buffer_1.Buffer.from(accessKeyStr, 'base64'));
        });
        Native.LookupRequest_setReturnAcisWithoutUaks(request, returnAcisWithoutUaks);
        const lookup = await this.asyncContext.makeCancellable(abortSignal, Native.CdsiLookup_new(this.asyncContext, this.connectionManager, username, password, request));
        return await this.asyncContext.makeCancellable(abortSignal, Native.CdsiLookup_complete(this.asyncContext, newNativeHandle(lookup)));
    }
}
exports.Net = Net;
/**
 * A simple data class containing the secret restored from SVR3 as well as the
 * number of restore attempts remaining.
 */
class RestoredSecret {
    constructor(serialized) {
        this.triesRemaining = serialized.readInt32BE();
        this.value = serialized.subarray(4);
    }
}
exports.RestoredSecret = RestoredSecret;
class Svr3ClientImpl {
    constructor(asyncContext, connectionManager) {
        this.asyncContext = asyncContext;
        this.connectionManager = connectionManager;
    }
    async backup(what, password, maxTries, auth, options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.Svr3Backup(this.asyncContext, this.connectionManager, what, password, maxTries, auth.username, auth.password));
    }
    async restore(password, shareSet, auth, options) {
        const serialized = await this.asyncContext.makeCancellable(options?.abortSignal, Native.Svr3Restore(this.asyncContext, this.connectionManager, password, shareSet, auth.username, auth.password));
        return new RestoredSecret(serialized);
    }
    async remove(auth, options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.Svr3Remove(this.asyncContext, this.connectionManager, auth.username, auth.password));
    }
}
//# sourceMappingURL=net.js.map