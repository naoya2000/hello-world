/// <reference types="node" />
import * as Native from '../Native';
export declare enum ServiceIdKind {
    Aci = 0,
    Pni = 1
}
/**
 * Typed representation of a Signal service ID, which can be one of various types.
 *
 * Conceptually this is a UUID in a particular "namespace" representing a particular way to reach a
 * user on the Signal service.
 */
export declare abstract class ServiceId extends Object {
    private readonly serviceIdFixedWidthBinary;
    constructor(serviceIdFixedWidthBinary: Buffer);
    protected static fromUuidBytesAndKind<T extends typeof ServiceId>(this: new (serviceIdFixedWidthBinary: Buffer) => InstanceType<T>, uuidBytes: ArrayLike<number>, kind: ServiceIdKind): InstanceType<T>;
    getServiceIdBinary(): Buffer;
    getServiceIdFixedWidthBinary(): Buffer;
    getServiceIdString(): string;
    toString(): string;
    private downcastTo;
    static parseFromServiceIdFixedWidthBinary<T extends typeof ServiceId>(this: T, serviceIdFixedWidthBinary: Buffer): InstanceType<T>;
    static parseFromServiceIdBinary<T extends typeof ServiceId>(this: T, serviceIdBinary: Buffer): InstanceType<T>;
    static parseFromServiceIdString<T extends typeof ServiceId>(this: T, serviceIdString: string): InstanceType<T>;
    getRawUuid(): string;
    getRawUuidBytes(): Buffer;
    isEqual(other: ServiceId): boolean;
    /**
     * Orders ServiceIds by kind, then lexicographically by the bytes of the UUID.
     *
     * Compatible with <code>Array.sort</code>.
     */
    static comparator(this: void, lhs: ServiceId, rhs: ServiceId): number;
    static toConcatenatedFixedWidthBinary(serviceIds: ServiceId[]): Buffer;
}
export declare class Aci extends ServiceId {
    private readonly __type?;
    static fromUuid(uuidString: string): Aci;
    static fromUuidBytes(uuidBytes: ArrayLike<number>): Aci;
}
export declare class Pni extends ServiceId {
    private readonly __type?;
    static fromUuid(uuidString: string): Pni;
    static fromUuidBytes(uuidBytes: ArrayLike<number>): Pni;
}
export declare class ProtocolAddress {
    readonly _nativeHandle: Native.ProtocolAddress;
    private constructor();
    static _fromNativeHandle(handle: Native.ProtocolAddress): ProtocolAddress;
    static new(name: string | ServiceId, deviceId: number): ProtocolAddress;
    name(): string;
    /**
     * Returns a ServiceId if this address contains a valid ServiceId, `null` otherwise.
     *
     * In a future release ProtocolAddresses will *only* support ServiceIds.
     */
    serviceId(): ServiceId | null;
    deviceId(): number;
    toString(): string;
}
