"use strict";
//
// Copyright 2024 Signal Messenger, LLC.
// SPDX-License-Identifier: AGPL-3.0-only
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComparableBackup = exports.validate = exports.Purpose = exports.MessageBackupKey = exports.ValidationOutcome = void 0;
/**
 * Message backup validation routines.
 *
 * @module MessageBackup
 */
const Native = require("../Native");
/**
 * Result of validating a message backup bundle.
 */
class ValidationOutcome {
    /**
     * `true` if the backup is valid, `false` otherwise.
     *
     * If this is `true`, there might still be messages about unknown fields.
     */
    get ok() {
        return this.errorMessage == null;
    }
    constructor(outcome) {
        const { errorMessage, unknownFieldMessages } = outcome;
        this.errorMessage = errorMessage;
        this.unknownFieldMessages = unknownFieldMessages;
    }
}
exports.ValidationOutcome = ValidationOutcome;
/**
 * Key used to encrypt and decrypt a message backup bundle.
 */
class MessageBackupKey {
    /**
     * Create a public key from the given master key and ACI.
     *
     * `masterKeyBytes` should contain exactly 32 bytes.
     */
    constructor(masterKeyBytes, aci) {
        this._nativeHandle = Native.MessageBackupKey_New(masterKeyBytes, aci.getServiceIdFixedWidthBinary());
    }
}
exports.MessageBackupKey = MessageBackupKey;
// This must match the Rust version of the enum.
var Purpose;
(function (Purpose) {
    Purpose[Purpose["DeviceTransfer"] = 0] = "DeviceTransfer";
    Purpose[Purpose["RemoteBackup"] = 1] = "RemoteBackup";
})(Purpose = exports.Purpose || (exports.Purpose = {}));
/**
 * Validate a backup file
 *
 * @param backupKey The key to use to decrypt the backup contents.
 * @param purpose Whether the backup is intended for device-to-device transfer or remote storage.
 * @param inputFactory A function that returns new input streams that read the backup contents.
 * @param length The exact length of the input stream.
 * @returns The outcome of validation, including any errors and warnings.
 * @throws IoError If an IO error on the input occurs.
 */
async function validate(backupKey, purpose, inputFactory, length) {
    const firstStream = inputFactory();
    const secondStream = inputFactory();
    return new ValidationOutcome(await Native.MessageBackupValidator_Validate(backupKey, firstStream, secondStream, length, purpose));
}
exports.validate = validate;
/**
 * An in-memory representation of a backup file used to compare contents.
 *
 * When comparing the contents of two backups:
 *   1. Create a `ComparableBackup` instance for each of the inputs.
 *   2. Check the `unknownFields()` value; if it's not empty, some parts of the
 *      backup weren't parsed and won't be compared.
 *   3. Produce a canonical string for each backup with `comparableString()`.
 *   4. Compare the canonical string representations.
 *
 * The diff of the canonical strings (which may be rather large) will show the
 * differences between the logical content of the input backup files.
 */
class ComparableBackup {
    constructor(handle) {
        this._nativeHandle = handle;
    }
    /**
     * Read an unencrypted backup file into memory for comparison.
     *
     * @param purpose Whether the backup is intended for device-to-device transfer or remote storage.
     * @param input An input stream that reads the backup contents.
     * @param length The exact length of the input stream.
     * @returns The in-memory representation.
     * @throws BackupValidationError If an IO error occurs or the input is invalid.
     */
    static async fromUnencrypted(purpose, input, length) {
        const handle = await Native.ComparableBackup_ReadUnencrypted(input, length, purpose);
        return new ComparableBackup(handle);
    }
    /**
     * Produces a string representation of the contents.
     *
     * The returned strings for two backups will be equal if the backups contain
     * the same logical content. If two backups' strings are not equal, the diff
     * will show what is different between them.
     *
     * @returns a canonical string representation of the backup
     */
    comparableString() {
        return Native.ComparableBackup_GetComparableString(this);
    }
    /**
     * Unrecognized protobuf fields present in the backup.
     *
     * If this is not empty, some parts of the backup were not recognized and
     * won't be present in the string representation.
     */
    get unknownFields() {
        return Native.ComparableBackup_GetUnknownFields(this);
    }
}
exports.ComparableBackup = ComparableBackup;
//# sourceMappingURL=MessageBackup.js.map